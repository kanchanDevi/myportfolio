{"version":3,"file":"fresh.cjs.production.min.js","sources":["../src/state/immer.ts","../src/state/formState.ts","../src/form/CancelButton.tsx","../src/form/Tooltip.tsx","../src/fields/Select.tsx","../src/fields/Reference.tsx","../src/fields/Password.tsx","../src/fields/Tags.tsx","../src/fields/TextArea.tsx","../src/fields/Number.tsx","../src/fields/MarkdownInput.tsx","../src/fields/Markdown.tsx","../src/fields/Text.tsx","../src/fields/Toggle.tsx","../src/Field.tsx","../src/index.tsx"],"sourcesContent":["import produce from 'immer'\n\nexport const immer = (config) => (set, get) =>\n  config((fn) => set(produce(fn)), get)\n","import React from 'react'\nimport create from 'zustand'\nimport { immer } from './immer'\n\n// Woof on theses types.\n// TODO fix these types\nconst store = (set: (val: any) => any) => ({\n  data: {},\n  isReady: {},\n  defaultValues: {},\n  setForm: (formData: any, formId: string) =>\n    set((state: any) => {\n      state.data[formId] = { ...formData }\n    }),\n  setField: (id: string, value: any, formId: string) =>\n    set((state: any) => {\n      state.data[formId][id] = value\n    }),\n  setDefaults: (formData: any, formId: string) =>\n    set((state: any) => {\n      state.defaultValues[formId] = { ...formData }\n    }),\n  register: (formData: any, formId: string) =>\n    set((state: any) => {\n      state.data[formId] = { ...formData }\n      state.defaultValues[formId] = { ...formData }\n      state.isReady[formId] = true\n    }),\n  unregister: (formId: string) =>\n    set((state: any) => {\n      state.isReady[formId] = false\n    }),\n  registerField: (fieldId: string, defaultValue: any, formId: string) =>\n    set((state: any) => {\n      state.data[formId][fieldId] = defaultValue\n    }),\n  resetForm: (formId: string) =>\n    set((state: any) => {\n      state.data[formId] = state.defaultValues[formId]\n    }),\n})\n\nexport const useForm = create(immer(store))\n\nexport const FormContext = React.createContext(null)\n","import React from 'react'\nimport { useForm } from '../state/formState'\n\nconst CancelButton = ({\n  cancelAction,\n  cancelText = 'Cancel',\n  formId,\n}: Props) => {\n  const { data, setField, isReady, resetForm } = useForm()\n  return (\n    <button\n      id=\"fresh-cancel\"\n      className=\"fresh-button fresh-cancel\"\n      onClick={() => {\n        cancelAction(formId)\n        resetForm(formId)\n      }}\n      type=\"reset\"\n    >\n      {cancelText}\n    </button>\n  )\n}\n\ntype Props = {\n  cancelAction: (resetForm) => void\n  cancelText: string\n  formId: string\n}\nexport default CancelButton\n","import React from 'react'\nimport PropTypes from 'prop-types'\n\ninterface TooltipInterface {\n  tooltip: string\n  tooltipBackground: string\n  tooltipColor: string\n  tooltipIconColor: string\n}\n\nconst Tooltip = ({\n  tooltip,\n  tooltipBackground,\n  tooltipColor,\n  tooltipIconColor,\n}: TooltipInterface) => {\n  const tooltipStyle = {\n    '--fresh-tooltip-background': tooltipBackground,\n    '--fresh-tooltip-color': tooltipColor,\n    '--fresh-tooltip-icon-color': tooltipIconColor,\n  } as React.CSSProperties\n  return (\n    <span className=\"fresh-tooltip\" data-tooltip={tooltip} style={tooltipStyle}>\n      <svg\n        className=\"fresh-tooltip-icon\"\n        width=\"16\"\n        height=\"16\"\n        viewBox=\"0 0 16 16\"\n        fill=\"none\"\n        xmlns=\"http://www.w3.org/2000/svg\"\n      >\n        <path\n          fillRule=\"evenodd\"\n          clipRule=\"evenodd\"\n          d=\"M8 16C12.4183 16 16 12.4183 16 8C16 3.58172 12.4183 0 8 0C3.58172 0 0 3.58172 0 8C0 12.4183 3.58172 16 8 16ZM9.02539 5.91797H5.84668V7.79102H6.91309V11.127H5.84668V13H10.0098V11.127H9.02539V5.91797ZM6.89258 3.16309C6.83333 3.30892 6.80371 3.46615 6.80371 3.63477C6.80371 3.80339 6.83333 3.96289 6.89258 4.11328C6.95638 4.25911 7.04297 4.38672 7.15234 4.49609C7.26172 4.60547 7.38932 4.69206 7.53516 4.75586C7.68555 4.81966 7.84733 4.85156 8.02051 4.85156C8.18457 4.85156 8.33952 4.81966 8.48535 4.75586C8.63118 4.69206 8.75879 4.60547 8.86816 4.49609C8.97754 4.38672 9.06413 4.25911 9.12793 4.11328C9.19173 3.96289 9.22363 3.80339 9.22363 3.63477C9.22363 3.46615 9.19173 3.30892 9.12793 3.16309C9.06413 3.0127 8.97754 2.88281 8.86816 2.77344C8.75879 2.66406 8.63118 2.57747 8.48535 2.51367C8.33952 2.44987 8.18457 2.41797 8.02051 2.41797C7.84733 2.41797 7.68555 2.44987 7.53516 2.51367C7.38932 2.57747 7.26172 2.66406 7.15234 2.77344C7.04297 2.88281 6.95638 3.0127 6.89258 3.16309Z\"\n          fill={tooltipIconColor}\n        />\n      </svg>\n    </span>\n  )\n}\n\nTooltip.propTypes = {\n  tooltip: PropTypes.string,\n  tooltipBackground: PropTypes.string,\n  tooltipColor: PropTypes.string,\n  tooltipIconColor: PropTypes.string,\n}\n\nTooltip.defaultProps = {\n  tooltip: '',\n  tooltipBackground: '#eee',\n  tooltipColor: '#000',\n  tooltipIconColor: '#000',\n}\nexport default Tooltip\n","import React, { useEffect } from 'react'\nimport { FieldInterface } from './types'\nimport { useForm } from '../state/formState'\n\nconst Select = ({\n  options,\n  fieldId,\n  formId,\n  displayProperty = '',\n  valueProperty = '',\n  className = '',\n}: FieldInterface) => {\n  const { data, setField, registerField, defaultValues } = useForm()\n\n  useEffect(() => {\n    const defaultValue = defaultValues?.[formId]?.[fieldId]\n      ? defaultValues?.[formId]?.[fieldId]?.[valueProperty] ||\n        defaultValues?.[formId]?.[fieldId]\n      : options[0]\n    registerField(fieldId, defaultValue, formId)\n  }, [])\n  if (!(fieldId in data[formId])) return null\n\n  return (\n    <select\n      id={`fresh-${fieldId}-${formId}`}\n      className={`fresh-input fresh-input-select ${className}`}\n      onChange={e => setField(fieldId, e.target.value, formId)}\n      value={data[formId][fieldId]}\n    >\n      {options.map((option, i) => (\n        <option\n          value={option?.[valueProperty] || option}\n          key={`fresh-${fieldId}-${formId}-${i}`}\n          className=\"fresh-option\"\n        >\n          {option?.[displayProperty] || option}\n        </option>\n      ))}\n    </select>\n  )\n}\n\nexport default Select\n","import React, { useState, useEffect } from 'react'\nimport { useForm } from '../state/formState'\nimport { FieldInterface } from './types'\n\nconst Reference = ({\n  options,\n  fieldId,\n  keyProperty = 'id',\n  displayProperty,\n  placeholder = '',\n  className = '',\n  formId,\n}: FieldInterface) => {\n  const { data, setField, isReady, defaultValues, registerField } = useForm()\n  const [inputValue, setInputValue] = useState(defaultValues?.[formId]?.[fieldId]?.[displayProperty] || '')\n  const [isFocused, setIsFocused] = useState(false)\n\n  useEffect(() => {\n    const defaultValue = defaultValues?.[formId]?.[fieldId] ?? ''\n    registerField(fieldId, defaultValue, formId)\n  }, [])\n  if (!(fieldId in data[formId])) return null\n\n  // If the form is not registered or there is not data object\n  if (!isReady) return null\n  return (\n    <>\n      <input\n        id={`fresh-${fieldId}-${formId}`}\n        onChange={e => setInputValue(e.target.value)}\n        value={inputValue}\n        onFocus={() => setIsFocused(true)}\n        onBlur={() => setIsFocused(false)}\n        placeholder={placeholder}\n        type=\"text\"\n        className={`fresh-input fresh-input-reference ${className}`}\n      />\n      {isFocused && (\n        <div className=\"fresh-focused\">\n          {options\n            .filter(option =>\n              option[displayProperty]\n                .toLowerCase()\n                .includes(inputValue.toLowerCase())\n            )\n            .map(option => (\n              <div\n                key={option[keyProperty]}\n                style={{ padding: '0.75em' }}\n                onMouseDown={() => {\n                  setField(fieldId, option, formId)\n                  setInputValue(option[displayProperty])\n                }}\n              >\n                {option[displayProperty]}\n              </div>\n            ))}\n        </div>\n      )}\n    </>\n  )\n}\n\nexport default Reference\n","import React, { useEffect } from 'react'\nimport { useForm } from '../state/formState'\nimport { FieldInterface } from './types'\n\nconst Password = ({\n  placeholder,\n  className = '',\n  required,\n  fieldId,\n  strength = true,\n  type,\n  formId,\n}: FieldInterface) => {\n  const { data, setField, defaultValues, registerField } = useForm()\n  // If the form is not registered or there is not data object\n  useEffect(() => {\n    const defaultValue = defaultValues?.[formId]?.[fieldId] ?? ''\n    registerField(fieldId, defaultValue, formId)\n  }, [])\n  if (!(fieldId in data[formId])) return null\n\n  const strengthValue = calculateScore(data[formId][fieldId] ?? '')\n\n  let strengthMeter = {\n    background: '#ccc',\n    width: 'calc(193px * 0.25)',\n  }\n  if (strengthValue >= 2 && strengthValue < 3) {\n    strengthMeter = {\n      width: 'calc(193px * 0.5)',\n      background: 'red',\n    }\n  } else if (strengthValue >= 3 && strengthValue < 4) {\n    strengthMeter = {\n      width: 'calc(193px * 0.75)',\n      background: 'red',\n    }\n  } else if (strengthValue >= 4) {\n    strengthMeter = {\n      width: 'calc(193px * 1)',\n      background: 'green',\n    }\n  }\n  return (\n    <>\n      <input\n        className={`fresh-input fresh-input-password ${className}`}\n        placeholder={placeholder}\n        type={type}\n        required={required}\n        id={`fresh-${fieldId}-${formId}`}\n        value={data[formId][fieldId]}\n        onChange={e => setField(fieldId, e.target.value, formId)}\n      />\n      {strength && (\n        <div\n          style={{\n            height: '4px',\n            marginBottom: '1rem',\n            transition: '0.3s ease all',\n            ...strengthMeter,\n          }}\n        />\n      )}\n    </>\n  )\n}\n\nconst options = {\n  showText: true,\n  fieldPartialMatch: true,\n  minimumLength: 4,\n}\n\nfunction calculateScore(password: string) {\n  var score = 0\n\n  // password < options.minimumLength\n  if (password.length < options.minimumLength) {\n    return -1\n  }\n  // password length\n  score += password.length * 4\n\n  // password has 3 numbers\n  if (password.match(/(.*[0-9].*[0-9].*[0-9])/)) {\n    score += 5\n  }\n\n  // password has at least 2 sybols\n  var symbols: any = '.*[!,@,#,$,%,^,&,*,?,_,~]'\n  symbols = new RegExp('(' + symbols + symbols + ')')\n  if (password.match(symbols)) {\n    score += 5\n  }\n\n  // password has Upper and Lower chars\n  if (password.match(/([a-z].*[A-Z])|([A-Z].*[a-z])/)) {\n    score += 10\n  }\n\n  // password has number and chars\n  if (password.match(/([a-zA-Z])/) && password.match(/([0-9])/)) {\n    score += 15\n  }\n\n  // password has number and symbol\n  if (\n    password.match(/([!,@,#,$,%,^,&,*,?,_,~])/) &&\n    password.match(/([0-9])/)\n  ) {\n    score += 15\n  }\n\n  // password has char and symbol\n  if (\n    password.match(/([!,@,#,$,%,^,&,*,?,_,~])/) &&\n    password.match(/([a-zA-Z])/)\n  ) {\n    score += 15\n  }\n\n  // password is just numbers or chars\n  if (password.match(/^\\w+$/) || password.match(/^\\d+$/)) {\n    score -= 10\n  }\n\n  if (score > 100) {\n    score = 100\n  }\n\n  if (score < 0) {\n    score = 0\n  }\n\n  return score * 0.04\n}\n\nexport default Password\n","import React, { useEffect } from 'react'\nimport TagsInput from 'react-tagsinput'\nimport { FieldInterface } from './types'\nimport { useForm } from '../state/formState'\n\nconst Tags = ({ fieldId, className = '', formId }: FieldInterface) => {\n  const { data, setField, defaultValues, registerField } = useForm()\n\n  useEffect(() => {\n    const defaultValue = defaultValues?.[formId]?.[fieldId] ?? []\n    registerField(fieldId, defaultValue, formId)\n  }, [])\n  if (!(fieldId in data[formId])) return null\n\n  return (\n    <TagsInput\n      value={data[formId][fieldId] || []}\n      onChange={(value: string[]) => setField(fieldId, value, formId)}\n      className={`fresh-input-tags ${className}`}\n      id={`fresh-${fieldId}-${formId}`}\n      style={{\n        marginTop: '1rem',\n      }}\n    />\n  )\n}\n\nexport default Tags\n","import React, { useEffect } from 'react'\nimport { useForm } from '../state/formState'\n\ninterface RefValue {\n  id: string\n  text: string\n}\n\ntype Props = {\n  required?: boolean\n  children: string\n  type?: string\n  fieldId?: string\n  name?: string\n  label?: boolean\n  error?: string\n  placeholder?: string\n  options: any\n  className?: string\n  tooltip?: string\n  strength?: boolean\n  displayProperty?: string\n  formId: string\n}\n\nexport const TextArea: React.FC<Props> = ({\n  className,\n  fieldId,\n  formId,\n  placeholder,\n}) => {\n  const { data, setField, registerField, defaultValues } = useForm()\n\n  useEffect(() => {\n    const defaultValue = defaultValues?.[formId]?.[fieldId] ?? ''\n    registerField(fieldId, defaultValue, formId)\n  }, [])\n  if (!(fieldId in data[formId])) return null\n\n  return (\n    <textarea\n      id={`fresh-${fieldId}-${formId}`}\n      placeholder={placeholder}\n      value={data[formId][fieldId]}\n      className={`fresh-input fresh-input-textarea ${className}`}\n      onChange={e => setField(fieldId, e.target.value, formId)}\n    />\n  )\n}\n\nexport default TextArea\n","import React, { useEffect } from 'react'\nimport { useForm } from '../state/formState'\nimport { FieldInterface } from './types'\n\nconst NumberField = ({\n  fieldId,\n  placeholder,\n  required,\n  formId,\n  className,\n}: FieldInterface) => {\n  const { data, setField, defaultValues, registerField } = useForm()\n  useEffect(() => {\n    const defaultValue = defaultValues?.[formId]?.[fieldId] ?? ''\n    registerField(fieldId, defaultValue, formId)\n  }, [])\n  if (!(fieldId in data[formId])) return null\n\n  return (\n    <input\n      required={required}\n      className={`fresh-input fresh-input-number ${className}`}\n      placeholder={placeholder}\n      id={`fresh-${fieldId}-${formId}`}\n      type=\"number\"\n      value={data[formId][fieldId]}\n      onChange={e => {\n        const value = e.target.value ? parseInt(e.target.value) : null\n        setField(fieldId, value, formId)\n      }}\n    />\n  )\n}\n\nexport default NumberField\n","/* @jsx h */\n/**\n * markdown-to-jsx@6 is a fork of [simple-markdown v0.2.2](https://github.com/Khan/simple-markdown)\n * from Khan Academy. Thank you Khan devs for making such an awesome and extensible\n * parsing infra... without it, half of the optimizations here wouldn't be feasible. 🙏🏼\n */\nimport React from 'react'\nimport unquote from 'unquote'\n\nexport namespace MarkdownToJSX {\n  /**\n   * RequireAtLeastOne<{ ... }> <- only requires at least one key\n   */\n  type RequireAtLeastOne<T, Keys extends keyof T = keyof T> = Pick<\n    T,\n    Exclude<keyof T, Keys>\n  > &\n    {\n      [K in Keys]-?: Required<Pick<T, K>> & Partial<Pick<T, Exclude<Keys, K>>>\n    }[Keys]\n\n  export type CreateElement = typeof React.createElement\n\n  export type HTMLTags = keyof JSX.IntrinsicElements\n\n  export type State = {\n    _list?: boolean\n    inline?: boolean\n    inTable?: boolean\n    key?: React.Key\n    simple?: boolean\n  }\n\n  export type ParserResult = {\n    [key: string]: any\n    type?: string\n  }\n\n  export type NestedParser = (\n    input: string,\n    state?: MarkdownToJSX.State\n  ) => MarkdownToJSX.ParserResult\n\n  export type Parser<ParserOutput> = (\n    capture: RegExpMatchArray,\n    nestedParse: NestedParser,\n    state?: MarkdownToJSX.State\n  ) => ParserOutput\n\n  export type RuleOutput = (\n    ast: MarkdownToJSX.ParserResult,\n    state: MarkdownToJSX.State\n  ) => JSX.Element\n\n  export type Rule<ParserOutput = MarkdownToJSX.ParserResult> = {\n    match: (\n      source: string,\n      state: MarkdownToJSX.State,\n      prevCapturedString?: string\n    ) => RegExpMatchArray\n    order: Priority\n    parse: MarkdownToJSX.Parser<ParserOutput>\n    react?: (\n      node: ParserOutput,\n      output: RuleOutput,\n      state?: MarkdownToJSX.State\n    ) => React.ReactChild\n  }\n\n  export type Rules = {\n    [key: string]: Rule\n  }\n\n  export type Override =\n    | RequireAtLeastOne<{\n        component: React.ElementType\n        props: Object\n      }>\n    | React.ElementType\n\n  export type Overrides = {\n    [tag in HTMLTags]?: Override\n  } & {\n    [customComponent: string]: Override\n  }\n\n  export type Options = Partial<{\n    /**\n     * Ultimate control over the output of all rendered JSX.\n     */\n    createElement: (\n      tag: Parameters<CreateElement>[0],\n      props: React.Props<any>,\n      ...children: React.ReactChild[]\n    ) => JSX.Element\n\n    /**\n     * Disable the compiler's best-effort transcription of provided raw HTML\n     * into JSX-equivalent. This is the functionality that prevents the need to\n     * use `dangerouslySetInnerHTML` in React.\n     */\n    disableParsingRawHTML: boolean\n\n    /**\n     * Forces the compiler to always output content with a block-level wrapper\n     * (`<p>` or any block-level syntax your markdown already contains.)\n     */\n    forceBlock: boolean\n\n    /**\n     * Forces the compiler to always output content with an inline wrapper (`<span>`)\n     */\n    forceInline: boolean\n\n    /**\n     * Supply additional HTML entity: unicode replacement mappings.\n     *\n     * Pass only the inner part of the entity as the key,\n     * e.g. `&le;` -> `{ \"le\": \"\\u2264\" }`\n     *\n     * By default\n     * the following entites are replaced with their unicode equivalents:\n     *\n     * ```\n     * &amp;\n     * &apos;\n     * &gt;\n     * &lt;\n     * &nbsp;\n     * &quot;\n     * ```\n     */\n    namedCodesToUnicode: {\n      [key: string]: string\n    }\n\n    /**\n     * Selectively control the output of particular HTML tags as they would be\n     * emitted by the compiler.\n     */\n    overrides: Overrides\n\n    /**\n     * Declare the type of the wrapper to be used when there are multiple\n     * children to render. Set to `null` to get an array of children back\n     * without any wrapper, or use `React.Fragment` to get a React element\n     * that won't show up in the DOM.\n     */\n    wrapper: React.ElementType\n\n    /**\n     * Forces the compiler to wrap results, even if there is only a single\n     * child or no children.\n     */\n    forceWrapper: boolean\n\n    /**\n     * Override normalization of non-URI-safe characters for use in generating\n     * HTML IDs for anchor linking purposes.\n     */\n    slugify: (source: string) => string\n  }>\n}\n\n/** TODO: Drop for React 16? */\nconst ATTRIBUTE_TO_JSX_PROP_MAP = {\n  accesskey: 'accessKey',\n  allowfullscreen: 'allowFullScreen',\n  allowtransparency: 'allowTransparency',\n  autocomplete: 'autoComplete',\n  autofocus: 'autoFocus',\n  autoplay: 'autoPlay',\n  cellpadding: 'cellPadding',\n  cellspacing: 'cellSpacing',\n  charset: 'charSet',\n  class: 'className',\n  classid: 'classId',\n  colspan: 'colSpan',\n  contenteditable: 'contentEditable',\n  contextmenu: 'contextMenu',\n  crossorigin: 'crossOrigin',\n  enctype: 'encType',\n  for: 'htmlFor',\n  formaction: 'formAction',\n  formenctype: 'formEncType',\n  formmethod: 'formMethod',\n  formnovalidate: 'formNoValidate',\n  formtarget: 'formTarget',\n  frameborder: 'frameBorder',\n  hreflang: 'hrefLang',\n  inputmode: 'inputMode',\n  keyparams: 'keyParams',\n  keytype: 'keyType',\n  marginheight: 'marginHeight',\n  marginwidth: 'marginWidth',\n  maxlength: 'maxLength',\n  mediagroup: 'mediaGroup',\n  minlength: 'minLength',\n  novalidate: 'noValidate',\n  radiogroup: 'radioGroup',\n  readonly: 'readOnly',\n  rowspan: 'rowSpan',\n  spellcheck: 'spellCheck',\n  srcdoc: 'srcDoc',\n  srclang: 'srcLang',\n  srcset: 'srcSet',\n  tabindex: 'tabIndex',\n  usemap: 'useMap',\n} as const\n\nconst namedCodesToUnicode = {\n  amp: '\\u0026',\n  apos: '\\u0027',\n  gt: '\\u003e',\n  lt: '\\u003c',\n  nbsp: '\\u00a0',\n  quot: '\\u201c',\n} as const\n\nconst DO_NOT_PROCESS_HTML_ELEMENTS = ['style', 'script']\n\n/**\n * the attribute extractor regex looks for a valid attribute name,\n * followed by an equal sign (whitespace around the equal sign is allowed), followed\n * by one of the following:\n *\n * 1. a single quote-bounded string, e.g. 'foo'\n * 2. a double quote-bounded string, e.g. \"bar\"\n * 3. an interpolation, e.g. {something}\n *\n * JSX can be be interpolated into itself and is passed through the compiler using\n * the same options and setup as the current run.\n *\n * <Something children={<SomeOtherThing />} />\n *                      ==================\n *                              ↳ children: [<SomeOtherThing />]\n *\n * Otherwise, interpolations are handled as strings or simple booleans\n * unless HTML syntax is detected.\n *\n * <Something color={green} disabled={true} />\n *                   =====            ====\n *                     ↓                ↳ disabled: true\n *                     ↳ color: \"green\"\n *\n * Numbers are not parsed at this time due to complexities around int, float,\n * and the upcoming bigint functionality that would make handling it unwieldy.\n * Parse the string in your component as desired.\n *\n * <Something someBigNumber={123456789123456789} />\n *                           ==================\n *                                   ↳ someBigNumber: \"123456789123456789\"\n */\nconst ATTR_EXTRACTOR_R = /([-A-Z0-9_:]+)(?:\\s*=\\s*(?:(?:\"((?:\\\\.|[^\"])*)\")|(?:'((?:\\\\.|[^'])*)')|(?:\\{((?:\\\\.|{[^}]*?}|[^}])*)\\})))?/gi\n\n/** TODO: Write explainers for each of these */\n\nconst AUTOLINK_MAILTO_CHECK_R = /mailto:/i\nconst BLOCK_END_R = /\\n{2,}$/\nconst BLOCKQUOTE_R = /^( *>[^\\n]+(\\n[^\\n]+)*\\n*)+\\n{2,}/\nconst BLOCKQUOTE_TRIM_LEFT_MULTILINE_R = /^ *> ?/gm\nconst BREAK_LINE_R = /^ {2,}\\n/\nconst BREAK_THEMATIC_R = /^(?:( *[-*_]) *){3,}(?:\\n *)+\\n/\nconst CODE_BLOCK_FENCED_R = /^\\s*(`{3,}|~{3,}) *(\\S+)? *\\n([\\s\\S]+?)\\s*\\1 *(?:\\n *)+\\n?/\nconst CODE_BLOCK_R = /^(?: {4}[^\\n]+\\n*)+(?:\\n *)+\\n?/\nconst CODE_INLINE_R = /^(`+)\\s*([\\s\\S]*?[^`])\\s*\\1(?!`)/\nconst CONSECUTIVE_NEWLINE_R = /^(?:\\n *)*\\n/\nconst CR_NEWLINE_R = /\\r\\n?/g\nconst FOOTNOTE_R = /^\\[\\^([^\\]]+)](:.*)\\n/\nconst FOOTNOTE_REFERENCE_R = /^\\[\\^([^\\]]+)]/\nconst FORMFEED_R = /\\f/g\nconst GFM_TASK_R = /^\\s*?\\[(x|\\s)\\]/\nconst HEADING_R = /^ *(#{1,6}) *([^\\n]+)\\n{0,2}/\nconst HEADING_SETEXT_R = /^([^\\n]+)\\n *(=|-){3,} *(?:\\n *)+\\n/\n\n/**\n * Explanation:\n *\n * 1. Look for a starting tag, preceeded by any amount of spaces\n *    ^ *<\n *\n * 2. Capture the tag name (capture 1)\n *    ([^ >/]+)\n *\n * 3. Ignore a space after the starting tag and capture the attribute portion of the tag (capture 2)\n *     ?([^>]*)\\/{0}>\n *\n * 4. Ensure a matching closing tag is present in the rest of the input string\n *    (?=[\\s\\S]*<\\/\\1>)\n *\n * 5. Capture everything until the matching closing tag -- this might include additional pairs\n *    of the same tag type found in step 2 (capture 3)\n *    ((?:[\\s\\S]*?(?:<\\1[^>]*>[\\s\\S]*?<\\/\\1>)*[\\s\\S]*?)*?)<\\/\\1>\n *\n * 6. Capture excess newlines afterward\n *    \\n*\n */\nconst HTML_BLOCK_ELEMENT_R = /^ *(?!<[a-z][^ >/]* ?\\/>)<([a-z][^ >/]*) ?([^>]*)\\/{0}>\\n?(\\s*(?:<\\1[^>]*?>[\\s\\S]*?<\\/\\1>|(?!<\\1)[\\s\\S])*?)<\\/\\1>\\n*/i\n\nconst HTML_CHAR_CODE_R = /&([a-z]+);/g\n\nconst HTML_COMMENT_R = /^<!--.*?-->/\n\n/**\n * borrowed from React 15(https://github.com/facebook/react/blob/894d20744cba99383ffd847dbd5b6e0800355a5c/src/renderers/dom/shared/HTMLDOMPropertyConfig.js)\n */\nconst HTML_CUSTOM_ATTR_R = /^(data|aria|x)-[a-z_][a-z\\d_.-]*$/\n\nconst HTML_SELF_CLOSING_ELEMENT_R = /^ *<([a-z][a-z0-9:]*)(?:\\s+((?:<.*?>|[^>])*))?\\/?>(?!<\\/\\1>)(\\s*\\n)?/i\nconst INTERPOLATION_R = /^\\{.*\\}$/\nconst LINK_AUTOLINK_BARE_URL_R = /^(https?:\\/\\/[^\\s<]+[^<.,:;\"')\\]\\s])/\nconst LINK_AUTOLINK_MAILTO_R = /^<([^ >]+@[^ >]+)>/\nconst LINK_AUTOLINK_R = /^<([^ >]+:\\/[^ >]+)>/\nconst LIST_ITEM_END_R = / *\\n+$/\nconst LIST_LOOKBEHIND_R = /(?:^|\\n)( *)$/\nconst CAPTURE_LETTER_AFTER_HYPHEN = /-([a-z])?/gi\nconst NP_TABLE_R = /^(.*\\|?.*)\\n *(\\|? *[-:]+ *\\|[-| :]*)\\n((?:.*\\|.*\\n)*)\\n?/\nconst PARAGRAPH_R = /^((?:[^\\n]|\\n(?! *\\n))+)(?:\\n *)+\\n/\nconst REFERENCE_IMAGE_OR_LINK = /^\\[([^\\]]*)\\]:\\s*(\\S+)\\s*(\"([^\"]*)\")?/\nconst REFERENCE_IMAGE_R = /^!\\[([^\\]]*)\\] ?\\[([^\\]]*)\\]/\nconst REFERENCE_LINK_R = /^\\[([^\\]]*)\\] ?\\[([^\\]]*)\\]/\nconst SQUARE_BRACKETS_R = /(\\[|\\])/g\nconst SHOULD_RENDER_AS_BLOCK_R = /(\\n|^[-*]\\s|^#|^ {2,}|^-{2,}|^>\\s)/\nconst TAB_R = /\\t/g\nconst TABLE_SEPARATOR_R = /^ *\\| */\nconst TABLE_TRIM_PIPES = /(^ *\\||\\| *$)/g\nconst TABLE_CELL_END_TRIM = / *$/\nconst TABLE_CENTER_ALIGN = /^ *:-+: *$/\nconst TABLE_LEFT_ALIGN = /^ *:-+ *$/\nconst TABLE_RIGHT_ALIGN = /^ *-+: *$/\n\nconst TEXT_BOLD_R = /^([*_])\\1((?:\\[.*?\\][([].*?[)\\]]|<.*?>(?:.*?<.*?>)?|`.*?`|~+.*?~+|.)*?)\\1\\1(?!\\1)/\nconst TEXT_EMPHASIZED_R = /^([*_])((?:\\[.*?\\][([].*?[)\\]]|<.*?>(?:.*?<.*?>)?|`.*?`|~+.*?~+|.)*?)\\1(?!\\1)/\nconst TEXT_STRIKETHROUGHED_R = /^~~((?:\\[.*?\\]|<.*?>(?:.*?<.*?>)?|`.*?`|.)*?)~~/\n\nconst TEXT_ESCAPED_R = /^\\\\([^0-9A-Za-z\\s])/\nconst TEXT_PLAIN_R = /^[\\s\\S]+?(?=[^0-9A-Z\\s\\u00c0-\\uffff&;.()'\"]|\\d+\\.|\\n\\n| {2,}\\n|\\w+:\\S|$)/i\nconst TRIM_NEWLINES_AND_TRAILING_WHITESPACE_R = /(^\\n+|\\n+$|\\s+$)/g\n\nconst HTML_LEFT_TRIM_AMOUNT_R = /^([ \\t]*)/\n\nconst UNESCAPE_URL_R = /\\\\([^0-9A-Z\\s])/gi\n\n// recognize a `*` `-`, `+`, `1.`, `2.`... list bullet\nconst LIST_BULLET = '(?:[*+-]|\\\\d+\\\\.)'\n\n// recognize the start of a list item:\n// leading space plus a bullet plus a space (`   * `)\nconst LIST_ITEM_PREFIX = '( *)(' + LIST_BULLET + ') +'\nconst LIST_ITEM_PREFIX_R = new RegExp('^' + LIST_ITEM_PREFIX)\n\n// recognize an individual list item:\n//  * hi\n//    this is part of the same item\n//\n//    as is this, which is a new paragraph in the same item\n//\n//  * but this is not part of the same item\nconst LIST_ITEM_R = new RegExp(\n  LIST_ITEM_PREFIX +\n    '[^\\\\n]*(?:\\\\n' +\n    '(?!\\\\1' +\n    LIST_BULLET +\n    ' )[^\\\\n]*)*(\\\\n|$)',\n  'gm'\n)\n\n// check whether a list item has paragraphs: if it does,\n// we leave the newlines at the end\nconst LIST_R = new RegExp(\n  '^( *)(' +\n    LIST_BULLET +\n    ') ' +\n    '[\\\\s\\\\S]+?(?:\\\\n{2,}(?! )' +\n    '(?!\\\\1' +\n    LIST_BULLET +\n    ' (?!' +\n    LIST_BULLET +\n    ' ))\\\\n*' +\n    // the \\\\s*$ here is so that we can parse the inside of nested\n    // lists, where our content might end before we receive two `\\n`s\n    '|\\\\s*\\\\n*$)'\n)\n\nconst LINK_INSIDE = '(?:\\\\[[^\\\\]]*\\\\]|[^\\\\[\\\\]]|\\\\](?=[^\\\\[]*\\\\]))*'\nconst LINK_HREF_AND_TITLE =\n  '\\\\s*<?((?:[^\\\\s\\\\\\\\]|\\\\\\\\.)*?)>?(?:\\\\s+[\\'\"]([\\\\s\\\\S]*?)[\\'\"])?\\\\s*'\n\nconst LINK_R = new RegExp(\n  '^\\\\[(' + LINK_INSIDE + ')\\\\]\\\\(' + LINK_HREF_AND_TITLE + '\\\\)'\n)\n\nconst IMAGE_R = new RegExp(\n  '^!\\\\[(' + LINK_INSIDE + ')\\\\]\\\\(' + LINK_HREF_AND_TITLE + '\\\\)'\n)\n\nconst BLOCK_SYNTAXES = [\n  BLOCKQUOTE_R,\n  CODE_BLOCK_R,\n  CODE_BLOCK_FENCED_R,\n  HEADING_R,\n  HEADING_SETEXT_R,\n  HTML_BLOCK_ELEMENT_R,\n  HTML_COMMENT_R,\n  HTML_SELF_CLOSING_ELEMENT_R,\n  LIST_ITEM_R,\n  LIST_R,\n  NP_TABLE_R,\n  PARAGRAPH_R,\n]\n\nfunction containsBlockSyntax(input: string) {\n  return BLOCK_SYNTAXES.some(r => r.test(input))\n}\n\n// based on https://stackoverflow.com/a/18123682/1141611\n// not complete, but probably good enough\nfunction slugify(str: string) {\n  return str\n    .replace(/[ÀÁÂÃÄÅàáâãäåæÆ]/g, 'a')\n    .replace(/[çÇ]/g, 'c')\n    .replace(/[ðÐ]/g, 'd')\n    .replace(/[ÈÉÊËéèêë]/g, 'e')\n    .replace(/[ÏïÎîÍíÌì]/g, 'i')\n    .replace(/[Ññ]/g, 'n')\n    .replace(/[øØœŒÕõÔôÓóÒò]/g, 'o')\n    .replace(/[ÜüÛûÚúÙù]/g, 'u')\n    .replace(/[ŸÿÝý]/g, 'y')\n    .replace(/[^a-z0-9- ]/gi, '')\n    .replace(/ /gi, '-')\n    .toLowerCase()\n}\n\nfunction parseTableAlignCapture(alignCapture: string) {\n  if (TABLE_RIGHT_ALIGN.test(alignCapture)) {\n    return 'right'\n  } else if (TABLE_CENTER_ALIGN.test(alignCapture)) {\n    return 'center'\n  } else if (TABLE_LEFT_ALIGN.test(alignCapture)) {\n    return 'left'\n  }\n\n  return null\n}\n\nfunction parseTableRow(\n  source: string,\n  parse: MarkdownToJSX.NestedParser,\n  state: MarkdownToJSX.State\n) {\n  const prevInTable = state.inTable\n  state.inTable = true\n  const tableRow = parse(source.trim(), state)\n  state.inTable = prevInTable\n\n  let cells = [[]]\n  tableRow.forEach(function(node, i) {\n    if (node.type === 'tableSeparator') {\n      // Filter out empty table separators at the start/end:\n      if (i !== 0 && i !== tableRow.length - 1) {\n        // Split the current row:\n        cells.push([])\n      }\n    } else {\n      if (\n        node.type === 'text' &&\n        (tableRow[i + 1] == null || tableRow[i + 1].type === 'tableSeparator')\n      ) {\n        node.content = node.content.replace(TABLE_CELL_END_TRIM, '')\n      }\n      cells[cells.length - 1].push(node)\n    }\n  })\n  return cells\n}\n\nfunction parseTableAlign(source: string /*, parse, state*/) {\n  const alignText = source.replace(TABLE_TRIM_PIPES, '').split('|')\n\n  return alignText.map(parseTableAlignCapture)\n}\n\nfunction parseTableCells(\n  source: string,\n  parse: MarkdownToJSX.NestedParser,\n  state: Object\n) {\n  const rowsText = source.trim().split('\\n')\n\n  return rowsText.map(function(rowText) {\n    return parseTableRow(rowText, parse, state)\n  })\n}\n\nfunction parseTable(\n  capture: RegExpMatchArray,\n  parse: MarkdownToJSX.NestedParser,\n  state: MarkdownToJSX.State\n) {\n  state.inline = true\n  const header = parseTableRow(capture[1], parse, state)\n  const align = parseTableAlign(capture[2])\n  const cells = parseTableCells(capture[3], parse, state)\n  state.inline = false\n\n  return {\n    align: align,\n    cells: cells,\n    header: header,\n    type: 'table',\n  }\n}\n\nfunction getTableStyle(node, colIndex) {\n  return node.align[colIndex] == null\n    ? {}\n    : {\n        textAlign: node.align[colIndex],\n      }\n}\n\n/** TODO: remove for react 16 */\nfunction normalizeAttributeKey(key) {\n  const hyphenIndex = key.indexOf('-')\n\n  if (hyphenIndex !== -1 && key.match(HTML_CUSTOM_ATTR_R) === null) {\n    key = key.replace(CAPTURE_LETTER_AFTER_HYPHEN, function(_, letter) {\n      return letter.toUpperCase()\n    })\n  }\n\n  return key\n}\n\nfunction attributeValueToJSXPropValue(\n  key: JSX.IntrinsicAttributes,\n  value: string\n): any {\n  if (key === 'style') {\n    return value.split(/;\\s?/).reduce(function(styles, kvPair) {\n      const key = kvPair.slice(0, kvPair.indexOf(':'))\n\n      // snake-case to camelCase\n      // also handles PascalCasing vendor prefixes\n      const camelCasedKey = key.replace(/(-[a-z])/g, substr =>\n        substr[1].toUpperCase()\n      )\n\n      // key.length + 1 to skip over the colon\n      styles[camelCasedKey] = kvPair.slice(key.length + 1).trim()\n\n      return styles\n    }, {})\n  } else if (key === 'href') {\n    return sanitizeUrl(value)\n  } else if (value.match(INTERPOLATION_R)) {\n    // return as a string and let the consumer decide what to do with it\n    value = value.slice(1, value.length - 1)\n  }\n\n  if (value === 'true') {\n    return true\n  } else if (value === 'false') {\n    return false\n  }\n\n  return value\n}\n\nfunction normalizeWhitespace(source: string): string {\n  return source\n    .replace(CR_NEWLINE_R, '\\n')\n    .replace(FORMFEED_R, '')\n    .replace(TAB_R, '    ')\n}\n\n/**\n * Creates a parser for a given set of rules, with the precedence\n * specified as a list of rules.\n *\n * @rules: an object containing\n * rule type -> {match, order, parse} objects\n * (lower order is higher precedence)\n * (Note: `order` is added to defaultRules after creation so that\n *  the `order` of defaultRules in the source matches the `order`\n *  of defaultRules in terms of `order` fields.)\n *\n * @returns The resulting parse function, with the following parameters:\n *   @source: the input source string to be parsed\n *   @state: an optional object to be threaded through parse\n *     calls. Allows clients to add stateful operations to\n *     parsing, such as keeping track of how many levels deep\n *     some nesting is. For an example use-case, see passage-ref\n *     parsing in src/widgets/passage/passage-markdown.jsx\n */\nfunction parserFor(\n  rules: MarkdownToJSX.Rules\n): (\n  source: string,\n  state: MarkdownToJSX.State\n) => ReturnType<MarkdownToJSX.NestedParser> {\n  // Sorts rules in order of increasing order, then\n  // ascending rule name in case of ties.\n  let ruleList = Object.keys(rules)\n\n  /* istanbul ignore next */\n  if (process.env.NODE_ENV !== 'production') {\n    ruleList.forEach(function(type) {\n      let order = rules[type].order\n      if (\n        process.env.NODE_ENV !== 'production' &&\n        (typeof order !== 'number' || !isFinite(order))\n      ) {\n        console.warn(\n          'markdown-to-jsx: Invalid order for rule `' + type + '`: ' + order\n        )\n      }\n    })\n  }\n\n  ruleList.sort(function(typeA, typeB) {\n    let orderA = rules[typeA].order\n    let orderB = rules[typeB].order\n\n    // First sort based on increasing order\n    if (orderA !== orderB) {\n      return orderA - orderB\n\n      // Then based on increasing unicode lexicographic ordering\n    } else if (typeA < typeB) {\n      return -1\n    }\n\n    return 1\n  })\n\n  function nestedParse(\n    source: string,\n    state: MarkdownToJSX.State\n  ): MarkdownToJSX.ParserResult[] {\n    let result = []\n\n    // We store the previous capture so that match functions can\n    // use some limited amount of lookbehind. Lists use this to\n    // ensure they don't match arbitrary '- ' or '* ' in inline\n    // text (see the list rule for more information).\n    let prevCapture = ''\n    while (source) {\n      let i = 0\n      while (i < ruleList.length) {\n        const ruleType = ruleList[i]\n        const rule = rules[ruleType]\n        const capture = rule.match(source, state, prevCapture)\n\n        if (capture) {\n          const currCaptureString = capture[0]\n          source = source.substring(currCaptureString.length)\n          const parsed = rule.parse(capture, nestedParse, state)\n\n          // We also let rules override the default type of\n          // their parsed node if they would like to, so that\n          // there can be a single output function for all links,\n          // even if there are several rules to parse them.\n          if (parsed.type == null) {\n            parsed.type = ruleType\n          }\n\n          result.push(parsed)\n\n          prevCapture = currCaptureString\n          break\n        }\n\n        i++\n      }\n    }\n\n    return result\n  }\n\n  return function outerParse(source, state) {\n    return nestedParse(normalizeWhitespace(source), state)\n  }\n}\n\n// Creates a match function for an inline scoped or simple element from a regex\nfunction inlineRegex(regex: RegExp) {\n  return function match(source, state) {\n    if (state.inline) {\n      return regex.exec(source)\n    } else {\n      return null\n    }\n  }\n}\n\n// basically any inline element except links\nfunction simpleInlineRegex(regex: RegExp) {\n  return function match(source: string, state: MarkdownToJSX.State) {\n    if (state.inline || state.simple) {\n      return regex.exec(source)\n    } else {\n      return null\n    }\n  }\n}\n\n// Creates a match function for a block scoped element from a regex\nfunction blockRegex(regex: RegExp) {\n  return function match(source: string, state: MarkdownToJSX.State) {\n    if (state.inline || state.simple) {\n      return null\n    } else {\n      return regex.exec(source)\n    }\n  }\n}\n\n// Creates a match function from a regex, ignoring block/inline scope\nfunction anyScopeRegex(regex: RegExp) {\n  return function match(source: string /*, state*/) {\n    return regex.exec(source)\n  }\n}\n\nfunction reactFor(outputFunc) {\n  return function nestedReactOutput(\n    ast: MarkdownToJSX.ParserResult | MarkdownToJSX.ParserResult[],\n    state: MarkdownToJSX.State = {}\n  ): React.ReactChild[] {\n    if (Array.isArray(ast)) {\n      const oldKey = state.key\n      const result = []\n\n      // map nestedOutput over the ast, except group any text\n      // nodes together into a single string output.\n      let lastWasString = false\n\n      for (let i = 0; i < ast.length; i++) {\n        state.key = i\n\n        const nodeOut = nestedReactOutput(ast[i], state)\n        const isString = typeof nodeOut === 'string'\n\n        if (isString && lastWasString) {\n          result[result.length - 1] += nodeOut\n        } else {\n          result.push(nodeOut)\n        }\n\n        lastWasString = isString\n      }\n\n      state.key = oldKey\n\n      return result\n    }\n\n    return outputFunc(ast, nestedReactOutput, state)\n  }\n}\n\nfunction sanitizeUrl(url: string): string | null {\n  try {\n    const decoded = decodeURIComponent(url).replace(/[^A-Za-z0-9/:]/g, '')\n\n    if (decoded.match(/^\\s*(javascript|vbscript|data):/i)) {\n      if (process.env.NODE_ENV !== 'production') {\n        console.warn(\n          'Anchor URL contains an unsafe JavaScript/VBScript/data expression, it will not be rendered.',\n          decoded\n        )\n      }\n\n      return null\n    }\n  } catch (e) {\n    if (process.env.NODE_ENV !== 'production') {\n      console.warn(\n        'Anchor URL could not be decoded due to malformed syntax or characters, it will not be rendered.',\n        url\n      )\n    }\n\n    // decodeURIComponent sometimes throws a URIError\n    // See `decodeURIComponent('a%AFc');`\n    // http://stackoverflow.com/questions/9064536/javascript-decodeuricomponent-malformed-uri-exception\n    return null\n  }\n\n  return url\n}\n\nfunction unescapeUrl(rawUrlString: string): string {\n  return rawUrlString.replace(UNESCAPE_URL_R, '$1')\n}\n\n/**\n * Everything inline, including links.\n */\nfunction parseInline(\n  parse: MarkdownToJSX.NestedParser,\n  content: string,\n  state: MarkdownToJSX.State\n): MarkdownToJSX.ParserResult {\n  const isCurrentlyInline = state.inline || false\n  const isCurrentlySimple = state.simple || false\n  state.inline = true\n  state.simple = true\n  const result = parse(content, state)\n  state.inline = isCurrentlyInline\n  state.simple = isCurrentlySimple\n  return result\n}\n\n/**\n * Anything inline that isn't a link.\n */\nfunction parseSimpleInline(\n  parse: MarkdownToJSX.NestedParser,\n  content: string,\n  state: MarkdownToJSX.State\n): MarkdownToJSX.ParserResult {\n  const isCurrentlyInline = state.inline || false\n  const isCurrentlySimple = state.simple || false\n  state.inline = false\n  state.simple = true\n  const result = parse(content, state)\n  state.inline = isCurrentlyInline\n  state.simple = isCurrentlySimple\n  return result\n}\n\nfunction parseBlock(parse, content, state): MarkdownToJSX.ParserResult {\n  state.inline = false\n  return parse(content + '\\n\\n', state)\n}\n\nconst parseCaptureInline: MarkdownToJSX.Parser<ReturnType<\n  typeof parseInline\n>> = (capture, parse, state) => {\n  return {\n    content: parseInline(parse, capture[1], state),\n  }\n}\n\nfunction captureNothing() {\n  return {}\n}\n\nfunction renderNothing() {\n  return null\n}\n\nfunction ruleOutput(rules: MarkdownToJSX.Rules) {\n  return function nestedRuleOutput(\n    ast: MarkdownToJSX.ParserResult,\n    outputFunc: MarkdownToJSX.RuleOutput,\n    state: MarkdownToJSX.State\n  ): React.ReactChild {\n    return rules[ast.type].react(ast, outputFunc, state)\n  }\n}\n\nfunction cx(...args) {\n  return args.filter(Boolean).join(' ')\n}\n\nfunction get(src: Object, path: string, fb?: any) {\n  let ptr = src\n  const frags = path.split('.')\n\n  while (frags.length) {\n    ptr = ptr[frags[0]]\n\n    if (ptr === undefined) break\n    else frags.shift()\n  }\n\n  return ptr || fb\n}\n\nfunction getTag(tag: string, overrides: MarkdownToJSX.Overrides) {\n  const override = get(overrides, tag)\n\n  if (!override) return tag\n\n  return typeof override === 'function' ||\n    (typeof override === 'object' && 'render' in override)\n    ? override\n    : get(overrides, `${tag}.component`, tag)\n}\n\nenum Priority {\n  /**\n   * anything that must scan the tree before everything else\n   */\n  MAX,\n  /**\n   * scans for block-level constructs\n   */\n  HIGH,\n  /**\n   * inline w/ more priority than other inline\n   */\n  MED,\n  /**\n   * inline elements\n   */\n  LOW,\n  /**\n   * bare text and stuff that is considered leftovers\n   */\n  MIN,\n}\n\nexport function compiler(\n  markdown: string,\n  options: MarkdownToJSX.Options = {}\n) {\n  options.overrides = options.overrides || {}\n  options.slugify = options.slugify || slugify\n  options.namedCodesToUnicode = options.namedCodesToUnicode\n    ? { ...namedCodesToUnicode, ...options.namedCodesToUnicode }\n    : namedCodesToUnicode\n\n  const createElementFn = options.createElement || React.createElement\n\n  // eslint-disable-next-line no-unused-vars\n  function h(\n    // locally we always will render a known string tag\n    tag: MarkdownToJSX.HTMLTags,\n    props: Parameters<MarkdownToJSX.CreateElement>[1] & {\n      className?: string\n    },\n    ...children\n  ) {\n    const overrideProps = get(options.overrides, `${tag}.props`, {})\n\n    return createElementFn(\n      getTag(tag, options.overrides),\n      {\n        ...props,\n        ...overrideProps,\n        className: cx(props?.className, overrideProps.className) || undefined,\n      },\n      ...children\n    )\n  }\n\n  function compile(input: string): JSX.Element {\n    let inline = false\n\n    if (options.forceInline) {\n      inline = true\n    } else if (!options.forceBlock) {\n      /**\n       * should not contain any block-level markdown like newlines, lists, headings,\n       * thematic breaks, blockquotes, tables, etc\n       */\n      inline = SHOULD_RENDER_AS_BLOCK_R.test(input) === false\n    }\n\n    const arr = emitter(\n      parser(\n        inline\n          ? input\n          : `${input.replace(TRIM_NEWLINES_AND_TRAILING_WHITESPACE_R, '')}\\n\\n`,\n        { inline }\n      )\n    )\n\n    if (options.wrapper === null) {\n      return arr\n    }\n\n    const wrapper = options.wrapper || (inline ? 'span' : 'div')\n    let jsx\n\n    if (arr.length > 1 || options.forceWrapper) {\n      jsx = arr\n    } else if (arr.length === 1) {\n      jsx = arr[0]\n\n      // TODO: remove this for React 16\n      if (typeof jsx === 'string') {\n        return <span key=\"outer\">{jsx}</span>\n      } else {\n        return jsx\n      }\n    } else {\n      // TODO: return null for React 16\n      jsx = null\n    }\n\n    return React.createElement(wrapper, { key: 'outer' }, jsx)\n  }\n\n  function attrStringToMap(str: string): React.Props<any> {\n    const attributes = str.match(ATTR_EXTRACTOR_R)\n\n    return attributes\n      ? attributes.reduce(function(map, raw, index) {\n          const delimiterIdx = raw.indexOf('=')\n\n          if (delimiterIdx !== -1) {\n            const key = normalizeAttributeKey(raw.slice(0, delimiterIdx)).trim()\n            const value = unquote(raw.slice(delimiterIdx + 1).trim())\n\n            const mappedKey = ATTRIBUTE_TO_JSX_PROP_MAP[key] || key\n            const normalizedValue = (map[\n              mappedKey\n            ] = attributeValueToJSXPropValue(key, value))\n\n            if (\n              typeof normalizedValue === 'string' &&\n              (HTML_BLOCK_ELEMENT_R.test(normalizedValue) ||\n                HTML_SELF_CLOSING_ELEMENT_R.test(normalizedValue))\n            ) {\n              map[mappedKey] = React.cloneElement(\n                compile(normalizedValue.trim()),\n                { key: index }\n              )\n            }\n          } else if (raw !== 'style') {\n            map[ATTRIBUTE_TO_JSX_PROP_MAP[raw] || raw] = true\n          }\n\n          return map\n        }, {})\n      : undefined\n  }\n\n  function stripHtmlComments(html) {\n    return html.replace(/<!--[\\s\\S]*?(?:-->)/g, '')\n  }\n\n  /* istanbul ignore next */\n  if (process.env.NODE_ENV !== 'production') {\n    if (typeof markdown !== 'string') {\n      throw new Error(`markdown-to-jsx: the first argument must be\n                             a string`)\n    }\n\n    if (\n      Object.prototype.toString.call(options.overrides) !== '[object Object]'\n    ) {\n      throw new Error(`markdown-to-jsx: options.overrides (second argument property) must be\n                             undefined or an object literal with shape:\n                             {\n                                htmltagname: {\n                                    component: string|ReactComponent(optional),\n                                    props: object(optional)\n                                }\n                             }`)\n    }\n  }\n\n  const footnotes: { footnote: string; identifier: string }[] = []\n  const refs: { [key: string]: { target: string; title: string } } = {}\n\n  /**\n   * each rule's react() output function goes through our custom h() JSX pragma;\n   * this allows the override functionality to be automatically applied\n   */\n  const rules: MarkdownToJSX.Rules = {\n    blockQuote: {\n      match: blockRegex(BLOCKQUOTE_R),\n      order: Priority.HIGH,\n      parse(capture, parse, state) {\n        return {\n          content: parse(\n            capture[0].replace(BLOCKQUOTE_TRIM_LEFT_MULTILINE_R, ''),\n            state\n          ),\n        }\n      },\n      react(node, output, state) {\n        return (\n          <blockquote key={state.key}>{output(node.content, state)}</blockquote>\n        )\n      },\n    } as MarkdownToJSX.Rule<{ content: MarkdownToJSX.ParserResult }>,\n\n    breakLine: {\n      match: anyScopeRegex(BREAK_LINE_R),\n      order: Priority.HIGH,\n      parse: captureNothing,\n      react(_, __, state) {\n        return <br key={state.key} />\n      },\n    },\n\n    breakThematic: {\n      match: blockRegex(BREAK_THEMATIC_R),\n      order: Priority.HIGH,\n      parse: captureNothing,\n      react(_, __, state) {\n        return <hr key={state.key} />\n      },\n    },\n\n    codeBlock: {\n      match: blockRegex(CODE_BLOCK_R),\n      order: Priority.MAX,\n      parse(capture /*, parse, state*/) {\n        return {\n          content: capture[0].replace(/^ {4}/gm, '').replace(/\\n+$/, ''),\n          lang: undefined,\n        }\n      },\n\n      react(node, output, state) {\n        return (\n          <pre key={state.key}>\n            <code className={node.lang ? `lang-${node.lang}` : ''}>\n              {node.content}\n            </code>\n          </pre>\n        )\n      },\n    } as MarkdownToJSX.Rule<{ content: string; lang?: string }>,\n\n    codeFenced: {\n      match: blockRegex(CODE_BLOCK_FENCED_R),\n      order: Priority.MAX,\n      parse(capture /*, parse, state*/) {\n        return {\n          content: capture[3],\n          lang: capture[2] || undefined,\n          type: 'codeBlock',\n        }\n      },\n    },\n\n    codeInline: {\n      match: simpleInlineRegex(CODE_INLINE_R),\n      order: Priority.LOW,\n      parse(capture /*, parse, state*/) {\n        return {\n          content: capture[2],\n        }\n      },\n      react(node, output, state) {\n        return <code key={state.key}>{node.content}</code>\n      },\n    } as MarkdownToJSX.Rule<{ content: string }>,\n\n    /**\n     * footnotes are emitted at the end of compilation in a special <footer> block\n     */\n    footnote: {\n      match: blockRegex(FOOTNOTE_R),\n      order: Priority.MAX,\n      parse(capture /*, parse, state*/) {\n        footnotes.push({\n          footnote: capture[2],\n          identifier: capture[1],\n        })\n\n        return {}\n      },\n      react: renderNothing,\n    },\n\n    footnoteReference: {\n      match: inlineRegex(FOOTNOTE_REFERENCE_R),\n      order: Priority.HIGH,\n      parse(capture /*, parse*/) {\n        return {\n          content: capture[1],\n          target: `#${options.slugify(capture[1])}`,\n        }\n      },\n      react(node, output, state) {\n        return (\n          <a key={state.key} href={sanitizeUrl(node.target)}>\n            <sup key={state.key}>{node.content}</sup>\n          </a>\n        )\n      },\n    } as MarkdownToJSX.Rule<{ content: string; target: string }>,\n\n    gfmTask: {\n      match: inlineRegex(GFM_TASK_R),\n      order: Priority.HIGH,\n      parse(capture /*, parse, state*/) {\n        return {\n          completed: capture[1].toLowerCase() === 'x',\n        }\n      },\n      react(node, output, state) {\n        return (\n          <input\n            checked={node.completed}\n            key={state.key}\n            readOnly\n            type=\"checkbox\"\n          />\n        )\n      },\n    } as MarkdownToJSX.Rule<{ completed: boolean }>,\n\n    heading: {\n      match: blockRegex(HEADING_R),\n      order: Priority.HIGH,\n      parse(capture, parse, state) {\n        return {\n          content: parseInline(parse, capture[2], state),\n          id: options.slugify(capture[2]),\n          level: capture[1].length,\n        }\n      },\n      react(node, output, state) {\n        node.tag = `h${node.level}` as MarkdownToJSX.HTMLTags\n        return (\n          <node.tag id={node.id} key={state.key}>\n            {output(node.content, state)}\n          </node.tag>\n        )\n      },\n    } as MarkdownToJSX.Rule<{\n      content: MarkdownToJSX.ParserResult\n      id: string\n      level: number\n      tag: MarkdownToJSX.HTMLTags\n    }>,\n\n    headingSetext: {\n      match: blockRegex(HEADING_SETEXT_R),\n      order: Priority.MAX,\n      parse(capture, parse, state) {\n        return {\n          content: parseInline(parse, capture[1], state),\n          level: capture[2] === '=' ? 1 : 2,\n          type: 'heading',\n        }\n      },\n    },\n\n    htmlComment: {\n      match: anyScopeRegex(HTML_COMMENT_R),\n      order: Priority.HIGH,\n      parse() {\n        return {}\n      },\n      react: renderNothing,\n    },\n\n    image: {\n      match: simpleInlineRegex(IMAGE_R),\n      order: Priority.HIGH,\n      parse(capture /*, parse, state*/) {\n        return {\n          alt: capture[1],\n          target: unescapeUrl(capture[2]),\n          title: capture[3],\n        }\n      },\n      react(node, output, state) {\n        return (\n          <img\n            key={state.key}\n            alt={node.alt || undefined}\n            title={node.title || undefined}\n            src={sanitizeUrl(node.target)}\n          />\n        )\n      },\n    } as MarkdownToJSX.Rule<{ alt?: string; target: string; title?: string }>,\n\n    link: {\n      match: inlineRegex(LINK_R),\n      order: Priority.LOW,\n      parse(capture, parse, state) {\n        return {\n          content: parseSimpleInline(parse, capture[1], state),\n          target: unescapeUrl(capture[2]),\n          title: capture[3],\n        }\n      },\n      react(node, output, state) {\n        return (\n          <a key={state.key} href={sanitizeUrl(node.target)} title={node.title}>\n            {output(node.content, state)}\n          </a>\n        )\n      },\n    } as MarkdownToJSX.Rule<{\n      content: MarkdownToJSX.ParserResult\n      target: string\n      title?: string\n    }>,\n\n    // https://daringfireball.net/projects/markdown/syntax#autolink\n    linkAngleBraceStyleDetector: {\n      match: inlineRegex(LINK_AUTOLINK_R),\n      order: Priority.MAX,\n      parse(capture /*, parse, state*/) {\n        return {\n          content: [\n            {\n              content: capture[1],\n              type: 'text',\n            },\n          ],\n          target: capture[1],\n          type: 'link',\n        }\n      },\n    },\n\n    linkBareUrlDetector: {\n      match: inlineRegex(LINK_AUTOLINK_BARE_URL_R),\n      order: Priority.MAX,\n      parse(capture /*, parse, state*/) {\n        return {\n          content: [\n            {\n              content: capture[1],\n              type: 'text',\n            },\n          ],\n          target: capture[1],\n          title: undefined,\n          type: 'link',\n        }\n      },\n    },\n\n    linkMailtoDetector: {\n      match: inlineRegex(LINK_AUTOLINK_MAILTO_R),\n      order: Priority.MAX,\n      parse(capture /*, parse, state*/) {\n        let address = capture[1]\n        let target = capture[1]\n\n        // Check for a `mailto:` already existing in the link:\n        if (!AUTOLINK_MAILTO_CHECK_R.test(target)) {\n          target = 'mailto:' + target\n        }\n\n        return {\n          content: [\n            {\n              content: address.replace('mailto:', ''),\n              type: 'text',\n            },\n          ],\n          target: target,\n          type: 'link',\n        }\n      },\n    },\n\n    list: {\n      match(source, state, prevCapture) {\n        // We only want to break into a list if we are at the start of a\n        // line. This is to avoid parsing \"hi * there\" with \"* there\"\n        // becoming a part of a list.\n        // You might wonder, \"but that's inline, so of course it wouldn't\n        // start a list?\". You would be correct! Except that some of our\n        // lists can be inline, because they might be inside another list,\n        // in which case we can parse with inline scope, but need to allow\n        // nested lists inside this inline scope.\n        const isStartOfLine = LIST_LOOKBEHIND_R.exec(prevCapture)\n        const isListBlock = state._list || !state.inline\n\n        if (isStartOfLine && isListBlock) {\n          source = isStartOfLine[1] + source\n\n          return LIST_R.exec(source)\n        } else {\n          return null\n        }\n      },\n      order: Priority.HIGH,\n      parse(capture, parse, state) {\n        const bullet = capture[2]\n        const ordered = bullet.length > 1\n        const start = ordered ? +bullet : undefined\n        const items = capture[0]\n          // recognize the end of a paragraph block inside a list item:\n          // two or more newlines at end end of the item\n          .replace(BLOCK_END_R, '\\n')\n          .match(LIST_ITEM_R)\n\n        let lastItemWasAParagraph = false\n        const itemContent = items.map(function(item, i) {\n          // We need to see how far indented the item is:\n          const space = LIST_ITEM_PREFIX_R.exec(item)[0].length\n\n          // And then we construct a regex to \"unindent\" the subsequent\n          // lines of the items by that amount:\n          const spaceRegex = new RegExp('^ {1,' + space + '}', 'gm')\n\n          // Before processing the item, we need a couple things\n          const content = item\n            // remove indents on trailing lines:\n            .replace(spaceRegex, '')\n            // remove the bullet:\n            .replace(LIST_ITEM_PREFIX_R, '')\n\n          // Handling \"loose\" lists, like:\n          //\n          //  * this is wrapped in a paragraph\n          //\n          //  * as is this\n          //\n          //  * as is this\n          const isLastItem = i === items.length - 1\n          const containsBlocks = content.indexOf('\\n\\n') !== -1\n\n          // Any element in a list is a block if it contains multiple\n          // newlines. The last element in the list can also be a block\n          // if the previous item in the list was a block (this is\n          // because non-last items in the list can end with \\n\\n, but\n          // the last item can't, so we just \"inherit\" this property\n          // from our previous element).\n          const thisItemIsAParagraph =\n            containsBlocks || (isLastItem && lastItemWasAParagraph)\n          lastItemWasAParagraph = thisItemIsAParagraph\n\n          // backup our state for restoration afterwards. We're going to\n          // want to set state._list to true, and state.inline depending\n          // on our list's looseness.\n          const oldStateInline = state.inline\n          const oldStateList = state._list\n          state._list = true\n\n          // Parse inline if we're in a tight list, or block if we're in\n          // a loose list.\n          let adjustedContent\n          if (thisItemIsAParagraph) {\n            state.inline = false\n            adjustedContent = content.replace(LIST_ITEM_END_R, '\\n\\n')\n          } else {\n            state.inline = true\n            adjustedContent = content.replace(LIST_ITEM_END_R, '')\n          }\n\n          const result = parse(adjustedContent, state)\n\n          // Restore our state before returning\n          state.inline = oldStateInline\n          state._list = oldStateList\n\n          return result\n        })\n\n        return {\n          items: itemContent,\n          ordered: ordered,\n          start: start,\n        }\n      },\n      react(node, output, state) {\n        const Tag = node.ordered ? 'ol' : 'ul'\n\n        return (\n          <Tag key={state.key} start={node.start}>\n            {node.items.map(function generateListItem(item, i) {\n              return <li key={i}>{output(item, state)}</li>\n            })}\n          </Tag>\n        )\n      },\n    } as MarkdownToJSX.Rule<{\n      items: MarkdownToJSX.ParserResult[]\n      ordered: boolean\n      start?: number\n    }>,\n\n    newlineCoalescer: {\n      match: blockRegex(CONSECUTIVE_NEWLINE_R),\n      order: Priority.LOW,\n      parse: captureNothing,\n      react(/*node, output, state*/) {\n        return '\\n'\n      },\n    },\n\n    paragraph: {\n      match: blockRegex(PARAGRAPH_R),\n      order: Priority.LOW,\n      parse: parseCaptureInline,\n      react(node, output, state) {\n        return <p key={state.key}>{output(node.content, state)}</p>\n      },\n    } as MarkdownToJSX.Rule<ReturnType<typeof parseCaptureInline>>,\n\n    ref: {\n      match: inlineRegex(REFERENCE_IMAGE_OR_LINK),\n      order: Priority.MAX,\n      parse(capture /*, parse*/) {\n        refs[capture[1]] = {\n          target: capture[2],\n          title: capture[4],\n        }\n\n        return {}\n      },\n      react: renderNothing,\n    },\n\n    refImage: {\n      match: simpleInlineRegex(REFERENCE_IMAGE_R),\n      order: Priority.MAX,\n      parse(capture) {\n        return {\n          alt: capture[1] || undefined,\n          ref: capture[2],\n        }\n      },\n      react(node, output, state) {\n        return (\n          <img\n            key={state.key}\n            alt={node.alt}\n            src={sanitizeUrl(refs[node.ref].target)}\n            title={refs[node.ref].title}\n          />\n        )\n      },\n    } as MarkdownToJSX.Rule<{ alt?: string; ref: string }>,\n\n    refLink: {\n      match: inlineRegex(REFERENCE_LINK_R),\n      order: Priority.MAX,\n      parse(capture, parse, state) {\n        return {\n          content: parse(capture[1], state),\n          fallbackContent: parse(\n            capture[0].replace(SQUARE_BRACKETS_R, '\\\\$1'),\n            state\n          ),\n          ref: capture[2],\n        }\n      },\n      react(node, output, state) {\n        return refs[node.ref] ? (\n          <a\n            key={state.key}\n            href={sanitizeUrl(refs[node.ref].target)}\n            title={refs[node.ref].title}\n          >\n            {output(node.content, state)}\n          </a>\n        ) : (\n          <span key={state.key}>{output(node.fallbackContent, state)}</span>\n        )\n      },\n    } as MarkdownToJSX.Rule<{\n      content: MarkdownToJSX.ParserResult\n      fallbackContent: MarkdownToJSX.ParserResult\n      ref: string\n    }>,\n\n    table: {\n      match: blockRegex(NP_TABLE_R),\n      order: Priority.HIGH,\n      parse: parseTable,\n      react(node, output, state) {\n        return (\n          <table key={state.key}>\n            <thead>\n              <tr>\n                {node.header.map(function generateHeaderCell(content, i) {\n                  return (\n                    <th key={i} style={getTableStyle(node, i)}>\n                      {output(content, state)}\n                    </th>\n                  )\n                })}\n              </tr>\n            </thead>\n\n            <tbody>\n              {node.cells.map(function generateTableRow(row, i) {\n                return (\n                  <tr key={i}>\n                    {row.map(function generateTableCell(content, c) {\n                      return (\n                        <td key={c} style={getTableStyle(node, c)}>\n                          {output(content, state)}\n                        </td>\n                      )\n                    })}\n                  </tr>\n                )\n              })}\n            </tbody>\n          </table>\n        )\n      },\n    } as MarkdownToJSX.Rule<ReturnType<typeof parseTable>>,\n\n    tableSeparator: {\n      match: function(source, state) {\n        if (!state.inTable) {\n          return null\n        }\n        return TABLE_SEPARATOR_R.exec(source)\n      },\n      order: Priority.HIGH,\n      parse: function() {\n        return { type: 'tableSeparator' }\n      },\n      // These shouldn't be reached, but in case they are, be reasonable:\n      react() {\n        return ' | '\n      },\n    },\n\n    text: {\n      // Here we look for anything followed by non-symbols,\n      // double newlines, or double-space-newlines\n      // We break on any symbol characters so that this grammar\n      // is easy to extend without needing to modify this regex\n      match: anyScopeRegex(TEXT_PLAIN_R),\n      order: Priority.MIN,\n      parse(capture /*, parse, state*/) {\n        return {\n          content: capture[0]\n            // nbsp -> unicode equivalent for named chars\n            .replace(HTML_CHAR_CODE_R, (full, inner) => {\n              return options.namedCodesToUnicode[inner]\n                ? options.namedCodesToUnicode[inner]\n                : full\n            }),\n        }\n      },\n      react(node /*, output, state*/) {\n        return node.content\n      },\n    } as MarkdownToJSX.Rule<{ content: string }>,\n\n    textBolded: {\n      match: simpleInlineRegex(TEXT_BOLD_R),\n      order: Priority.MED,\n      parse(capture, parse, state) {\n        return {\n          // capture[1] -> the syntax control character\n          // capture[2] -> inner content\n          content: parse(capture[2], state),\n        }\n      },\n      react(node, output, state) {\n        return <strong key={state.key}>{output(node.content, state)}</strong>\n      },\n    } as MarkdownToJSX.Rule<ReturnType<MarkdownToJSX.NestedParser>>,\n\n    textEmphasized: {\n      match: simpleInlineRegex(TEXT_EMPHASIZED_R),\n      order: Priority.LOW,\n      parse(capture, parse, state) {\n        return {\n          // capture[1] -> opening * or _\n          // capture[2] -> inner content\n          content: parse(capture[2], state),\n        }\n      },\n      react(node, output, state) {\n        return <em key={state.key}>{output(node.content, state)}</em>\n      },\n    } as MarkdownToJSX.Rule<ReturnType<MarkdownToJSX.NestedParser>>,\n\n    textEscaped: {\n      // We don't allow escaping numbers, letters, or spaces here so that\n      // backslashes used in plain text still get rendered. But allowing\n      // escaping anything else provides a very flexible escape mechanism,\n      // regardless of how this grammar is extended.\n      match: simpleInlineRegex(TEXT_ESCAPED_R),\n      order: Priority.HIGH,\n      parse(capture /*, parse, state*/) {\n        return {\n          content: capture[1],\n          type: 'text',\n        }\n      },\n    },\n\n    textStrikethroughed: {\n      match: simpleInlineRegex(TEXT_STRIKETHROUGHED_R),\n      order: Priority.LOW,\n      parse: parseCaptureInline,\n      react(node, output, state) {\n        return <del key={state.key}>{output(node.content, state)}</del>\n      },\n    } as MarkdownToJSX.Rule<ReturnType<typeof parseCaptureInline>>,\n  }\n\n  // Object.keys(rules).forEach(key => {\n  //     let { match, parse } = rules[key];\n\n  //     rules[key].match = (...args) => {\n  //         const start = performance.now();\n  //         const result = match(...args);\n  //         const delta = performance.now() - start;\n\n  //         if (delta > 5)\n  //             console.warn(\n  //                 `Slow match for ${key}: ${delta.toFixed(3)}ms, input: ${\n  //                     args[0]\n  //                 }`\n  //             );\n\n  //         return result;\n  //     };\n\n  //     rules[key].parse = (...args) => {\n  //         const start = performance.now();\n  //         const result = parse(...args);\n  //         const delta = performance.now() - start;\n\n  //         if (delta > 5)\n  //             console.warn(`Slow parse for ${key}: ${delta.toFixed(3)}ms`);\n\n  //         console.log(`${key}:parse`, `${delta.toFixed(3)}ms`, args[0]);\n\n  //         return result;\n  //     };\n  // });\n\n  if (options.disableParsingRawHTML !== true) {\n    rules.htmlBlock = {\n      /**\n       * find the first matching end tag and process the interior\n       */\n      match: anyScopeRegex(HTML_BLOCK_ELEMENT_R),\n      order: Priority.HIGH,\n      parse(capture, parse, state) {\n        const [, whitespace] = capture[3].match(HTML_LEFT_TRIM_AMOUNT_R)\n        const trimmer = new RegExp(`^${whitespace}`, 'gm')\n        const trimmed = capture[3].replace(trimmer, '')\n\n        const parseFunc = containsBlockSyntax(trimmed)\n          ? parseBlock\n          : parseInline\n\n        const tagName = capture[1].toLowerCase() as MarkdownToJSX.HTMLTags\n        const noInnerParse =\n          DO_NOT_PROCESS_HTML_ELEMENTS.indexOf(tagName) !== -1\n\n        return {\n          attrs: attrStringToMap(capture[2]),\n          /**\n           * if another html block is detected within, parse as block,\n           * otherwise parse as inline to pick up any further markdown\n           */\n          content: noInnerParse ? capture[3] : parseFunc(parse, trimmed, state),\n\n          noInnerParse,\n\n          tag: noInnerParse ? tagName : capture[1],\n        }\n      },\n      react(node, output, state) {\n        return (\n          // @ts-ignore\n          <node.tag key={state.key} {...node.attrs}>\n            {node.noInnerParse\n              ? (node.content as string)\n              : output(node.content as MarkdownToJSX.ParserResult, state)}\n          </node.tag>\n        )\n      },\n    } as MarkdownToJSX.Rule<{\n      attrs: ReturnType<typeof attrStringToMap>\n      content: string | ReturnType<MarkdownToJSX.NestedParser>\n      noInnerParse: Boolean\n      tag: string\n    }>\n\n    rules.htmlSelfClosing = {\n      /**\n       * find the first matching end tag and process the interior\n       */\n      match: anyScopeRegex(HTML_SELF_CLOSING_ELEMENT_R),\n      order: Priority.HIGH,\n      parse(capture /*, parse, state*/) {\n        return {\n          attrs: attrStringToMap(capture[2] || ''),\n          tag: capture[1],\n        }\n      },\n      react(node, output, state) {\n        return <node.tag {...node.attrs} key={state.key} />\n      },\n    } as MarkdownToJSX.Rule<{\n      attrs: ReturnType<typeof attrStringToMap>\n      tag: string\n    }>\n  }\n\n  const parser = parserFor(rules)\n  const emitter: Function = reactFor(ruleOutput(rules))\n\n  const jsx = compile(stripHtmlComments(markdown))\n\n  if (footnotes.length) {\n    jsx.props.children.push(\n      <footer key=\"footer\">\n        {footnotes.map(function createFootnote(def) {\n          return (\n            <div id={options.slugify(def.identifier)} key={def.identifier}>\n              {def.identifier}\n              {emitter(parser(def.footnote, { inline: true }))}\n            </div>\n          )\n        })}\n      </footer>\n    )\n  }\n\n  return jsx\n}\n\n/**\n * A simple HOC for easy React use. Feed the markdown content as a direct child\n * and the rest is taken care of automatically.\n */\nconst Markdown: React.FC<{\n  [key: string]: any\n  children: string\n  options?: MarkdownToJSX.Options\n}> = ({ children, options, ...props }) => {\n  return React.cloneElement(\n    compiler(children, options),\n    props as React.Props<any>\n  )\n}\n\nexport default Markdown\n","import React, { useEffect } from 'react'\nimport Markdown from './MarkdownInput'\nimport { useForm } from '../state/formState'\n\nimport { FieldInterface } from './types'\n\nexport const MarkdownTextArea = ({\n  fieldId,\n  placeholder,\n  formId,\n}: FieldInterface) => {\n  const { data, setField, defaultValues, registerField } = useForm()\n  useEffect(() => {\n    const defaultValue = defaultValues?.[formId]?.[fieldId] ?? ''\n    registerField(fieldId, defaultValue, formId)\n  }, [])\n  if (!(fieldId in data[formId])) return null\n\n  return (\n    <div className=\"fresh-markdown-wrapper\">\n      <textarea\n        id={`fresh-${fieldId}`}\n        placeholder={placeholder}\n        value={data[formId][fieldId]}\n        className=\"fresh-input fresh-input-textarea\"\n        onChange={e => setField(fieldId, e.target.value, formId)}\n      />\n      <div className=\"fresh-input fresh-input-markdown\">\n        <Markdown children={data[formId][fieldId] || ''} />\n      </div>\n    </div>\n  )\n}\n\nexport default MarkdownTextArea\n","import React, { useEffect } from 'react'\nimport { FieldInterface } from './types'\nimport { useForm } from '../state/formState'\n\nconst Text = ({\n  className,\n  fieldId,\n  placeholder,\n  required,\n  type,\n  formId,\n}: FieldInterface) => {\n  const { data, setField, registerField, defaultValues } = useForm()\n  useEffect(() => {\n    const defaultValue = defaultValues?.[formId]?.[fieldId] ?? ''\n    registerField(fieldId, defaultValue, formId)\n  }, [])\n  if (!(fieldId in data[formId])) return null\n\n  return (\n    <input\n      required={required}\n      className={`fresh-input fresh-input-${type} ${className}`}\n      placeholder={placeholder}\n      id={`fresh-${fieldId}-${formId}`}\n      type={type}\n      value={data[formId][fieldId]}\n      onChange={e => setField(fieldId, e.target.value, formId)}\n    />\n  )\n}\n\nexport default Text\n","import React, { useEffect } from 'react'\nimport { FieldInterface } from './types'\nimport { useForm } from '../state/formState'\n\nconst Toggle = ({ fieldId, className = '', formId }: FieldInterface) => {\n  const { data, setField, defaultValues, registerField } = useForm()\n  useEffect(() => {\n    const defaultValue = defaultValues?.[formId]?.[fieldId] ?? false\n    registerField(fieldId, defaultValue, formId)\n  }, [])\n  if (!(fieldId in data[formId])) return null\n\n  return (\n    <div className={`${className} fresh-switch`}>\n      <input\n        checked={data[formId][fieldId] || false}\n        type=\"checkbox\"\n        id={`fresh-${fieldId}`}\n        className=\"fresh-input-toggle\"\n        onChange={_ => setField(fieldId, !data[formId][fieldId], formId)}\n      />\n      <span\n        className={`fresh-slider ${data[formId][fieldId] ? `on` : ''}`}\n        onChange={_ => setField(fieldId, !data[formId][fieldId], formId)}\n      />\n    </div>\n  )\n}\n\nexport default Toggle\n","import React, { useContext } from 'react'\nimport { FormContext } from './state/formState'\nimport { FieldInterface } from './fields/types'\nimport Tooltip from './form/Tooltip'\nimport Select from './fields/Select'\nimport Reference from './fields/Reference'\nimport Password from './fields/Password'\nimport Tags from './fields/Tags'\nimport TextArea from './fields/TextArea'\nimport NumberField from './fields/Number'\nimport Markdown from './fields/Markdown'\nimport Text from './fields/Text'\nimport Toggle from './fields/Toggle'\n\nconst camelCase = str => {\n  return str.replace(/(?:^\\w|[A-Z]|\\b\\w|\\s+)/g, function(match, index) {\n    if (+match === 0) return ''\n    return index == 0 ? match.toLowerCase() : match.toUpperCase()\n  })\n}\n\nconst Field = ({\n  required = false,\n  children,\n  name = '',\n  type = 'text',\n  label = true,\n  error,\n  placeholder = '',\n  options,\n  strength,\n  className = '',\n  defaultValue = '',\n  displayProperty = '',\n  valueProperty = '',\n  keyProperty = 'id',\n  tooltip,\n  readOnly = false,\n  wrapperStyle = {},\n}: FieldInterface) => {\n  const fieldId = name || camelCase(children)\n  const { formId } = useContext(FormContext)\n\n  const standardProps = {\n    children,\n    required,\n    name,\n    type,\n    label,\n    error,\n    placeholder,\n    options,\n    className,\n    defaultValue,\n    displayProperty,\n    readOnly,\n    formId,\n  }\n  return (\n    <div className={`fresh-field-wrapper ${fieldId}`} style={wrapperStyle}>\n      <label className=\"fresh-label\" htmlFor={`fresh-${fieldId}`}>\n        <span className=\"fresh-title\">\n          {required && '*'} {label && children}&nbsp;\n          {tooltip && <Tooltip tooltip={tooltip} />}\n        </span>\n        {(() => {\n          switch (type) {\n            case 'select':\n              return (\n                <Select\n                  fieldId={fieldId}\n                  valueProperty={valueProperty}\n                  {...standardProps}\n                />\n              )\n            case 'reference':\n              return (\n                <Reference\n                  fieldId={fieldId}\n                  keyProperty={keyProperty}\n                  {...standardProps}\n                />\n              )\n            case 'password':\n              return (\n                <Password\n                  strength={strength}\n                  fieldId={fieldId}\n                  {...standardProps}\n                />\n              )\n            case 'tags':\n              return <Tags fieldId={fieldId} {...standardProps} />\n            case 'textarea':\n              return <TextArea fieldId={fieldId} {...standardProps} />\n            case 'number':\n              return <NumberField fieldId={fieldId} {...standardProps} />\n            case 'markdown':\n              return <Markdown fieldId={fieldId} {...standardProps} />\n            case 'toggle':\n              return <Toggle fieldId={fieldId} {...standardProps} />\n            default:\n              return <Text fieldId={fieldId} {...standardProps} />\n          }\n        })()}\n      </label>\n      {error && <div className=\"fresh-error\">{error}</div>}\n    </div>\n  )\n}\n\nField.defaultProps = {\n  defaultValue: null,\n  options: [],\n  tooltip: '',\n}\n\nexport default Field\n","import React, { useEffect } from 'react'\nimport { useForm, FormContext } from './state/formState'\nimport CancelButton from './form/CancelButton'\nexport { default as Field } from './Field'\nimport './fields/global.css'\n\ntype FormProps = {\n  cancelAction?: (_: any) => void\n  cancelButton?: boolean\n  cancelText?: string\n  formId: string\n  className?: string\n  defaultValues?: any // sorry. not sure how to type this properly PR wanted\n  onSubmit(formState: { [key: string]: any }): void\n  onChange?(formState: object): void\n  submitText?: string\n}\n\nconst Form: React.FC<FormProps> = ({\n  cancelAction = () => null,\n  onChange = null,\n  cancelButton = true,\n  cancelText = 'Cancel',\n  children,\n  formId,\n  onSubmit,\n  submitText = 'Submit',\n  className = '',\n  defaultValues = {},\n}) => {\n  const { data, register, isReady, unregister } = useForm()\n\n  useEffect(() => {\n    register(defaultValues, formId)\n    return () => {\n      unregister(formId)\n    }\n  }, [])\n\n  if (!isReady[formId]) return null\n\n  return (\n    <FormContext.Provider value={{ formId }}>\n      <form\n        className={`${className} fresh-form`}\n        onSubmit={e => {\n          e.preventDefault()\n          onSubmit(data[formId])\n        }}\n        onChange={() => {\n          if (onChange) onChange(data[formId])\n        }}\n      >\n        {children}\n        <div>\n          <button\n            id=\"fresh-submit\"\n            className=\"fresh-button fresh-submit\"\n            type=\"submit\"\n          >\n            {submitText}\n          </button>\n          {cancelButton && (\n            <CancelButton\n              formId={formId}\n              cancelAction={cancelAction}\n              cancelText={cancelText}\n            />\n          )}\n        </div>\n      </form>\n    </FormContext.Provider>\n  )\n}\n\n// TODO\n// AUto form prop that allows for automatic form building via graphql. Required fields and all\n\n// Future api idea <Form mutation={GRAPHQL_MUTATION} /> one liner\n\n// Reset on submit option\nexport { Form, useForm }\n"],"names":["useForm","create","config","set","get","data","isReady","defaultValues","setForm","formData","formId","state","setField","id","value","setDefaults","register","unregister","registerField","fieldId","defaultValue","resetForm","fn","produce","immer","FormContext","React","createContext","CancelButton","cancelAction","cancelText","className","onClick","type","Tooltip","tooltipIconColor","tooltip","style","tooltipBackground","tooltipColor","width","height","viewBox","fill","xmlns","fillRule","clipRule","d","propTypes","PropTypes","string","defaultProps","Select","options","displayProperty","valueProperty","useEffect","_defaultValues$formId4","onChange","e","target","map","option","i","key","Reference","keyProperty","placeholder","useState","inputValue","setInputValue","isFocused","setIsFocused","onFocus","onBlur","filter","toLowerCase","includes","padding","onMouseDown","Password","required","strength","_defaultValues$formId2","strengthValue","password","score","length","match","symbols","RegExp","calculateScore","strengthMeter","background","marginBottom","transition","Tags","TagsInput","marginTop","TextArea","NumberField","parseInt","ATTRIBUTE_TO_JSX_PROP_MAP","accesskey","allowfullscreen","allowtransparency","autocomplete","autofocus","autoplay","cellpadding","cellspacing","charset","classid","colspan","contenteditable","contextmenu","crossorigin","enctype","formaction","formenctype","formmethod","formnovalidate","formtarget","frameborder","hreflang","inputmode","keyparams","keytype","marginheight","marginwidth","maxlength","mediagroup","minlength","novalidate","radiogroup","readonly","rowspan","spellcheck","srcdoc","srclang","srcset","tabindex","usemap","namedCodesToUnicode","amp","apos","gt","lt","nbsp","quot","DO_NOT_PROCESS_HTML_ELEMENTS","ATTR_EXTRACTOR_R","AUTOLINK_MAILTO_CHECK_R","BLOCK_END_R","BLOCKQUOTE_R","BLOCKQUOTE_TRIM_LEFT_MULTILINE_R","BREAK_LINE_R","BREAK_THEMATIC_R","CODE_BLOCK_FENCED_R","CODE_BLOCK_R","CODE_INLINE_R","CONSECUTIVE_NEWLINE_R","CR_NEWLINE_R","FOOTNOTE_R","FOOTNOTE_REFERENCE_R","FORMFEED_R","GFM_TASK_R","HEADING_R","HEADING_SETEXT_R","HTML_BLOCK_ELEMENT_R","HTML_CHAR_CODE_R","HTML_COMMENT_R","HTML_CUSTOM_ATTR_R","HTML_SELF_CLOSING_ELEMENT_R","INTERPOLATION_R","LINK_AUTOLINK_BARE_URL_R","LINK_AUTOLINK_MAILTO_R","LINK_AUTOLINK_R","LIST_ITEM_END_R","LIST_LOOKBEHIND_R","CAPTURE_LETTER_AFTER_HYPHEN","NP_TABLE_R","PARAGRAPH_R","REFERENCE_IMAGE_OR_LINK","REFERENCE_IMAGE_R","REFERENCE_LINK_R","SQUARE_BRACKETS_R","SHOULD_RENDER_AS_BLOCK_R","TAB_R","TABLE_SEPARATOR_R","TABLE_TRIM_PIPES","TABLE_CELL_END_TRIM","TABLE_CENTER_ALIGN","TABLE_LEFT_ALIGN","TABLE_RIGHT_ALIGN","TEXT_BOLD_R","TEXT_EMPHASIZED_R","TEXT_STRIKETHROUGHED_R","TEXT_ESCAPED_R","TEXT_PLAIN_R","TRIM_NEWLINES_AND_TRAILING_WHITESPACE_R","HTML_LEFT_TRIM_AMOUNT_R","UNESCAPE_URL_R","LIST_ITEM_PREFIX_R","LIST_ITEM_R","LIST_ITEM_PREFIX","LIST_R","LINK_INSIDE","LINK_R","IMAGE_R","BLOCK_SYNTAXES","slugify","str","replace","parseTableAlignCapture","alignCapture","test","parseTableRow","source","parse","prevInTable","inTable","tableRow","trim","cells","forEach","node","push","content","parseTable","capture","inline","header","align","split","rowText","parseTableCells","getTableStyle","colIndex","textAlign","inlineRegex","regex","exec","simpleInlineRegex","simple","blockRegex","anyScopeRegex","sanitizeUrl","url","decodeURIComponent","unescapeUrl","rawUrlString","parseInline","isCurrentlyInline","isCurrentlySimple","result","parseSimpleInline","parseBlock","Priority","parseCaptureInline","captureNothing","renderNothing","cx","args","Boolean","join","src","path","fb","ptr","frags","undefined","shift","getTag","tag","overrides","override","Markdown","children","props","cloneElement","markdown","createElementFn","createElement","h","overrideProps","compile","input","forceInline","forceBlock","arr","emitter","parser","wrapper","jsx","forceWrapper","attrStringToMap","attributes","reduce","raw","index","delimiterIdx","indexOf","_","letter","toUpperCase","normalizeAttributeKey","slice","unquote","mappedKey","normalizedValue","styles","kvPair","substr","attributeValueToJSXPropValue","footnotes","refs","rules","blockQuote","order","HIGH","react","output","breakLine","__","breakThematic","codeBlock","MAX","lang","codeFenced","codeInline","LOW","footnote","identifier","footnoteReference","href","gfmTask","completed","checked","readOnly","heading","level","headingSetext","htmlComment","image","alt","title","link","linkAngleBraceStyleDetector","linkBareUrlDetector","linkMailtoDetector","address","list","prevCapture","isStartOfLine","_list","bullet","ordered","start","items","lastItemWasAParagraph","item","space","spaceRegex","isLastItem","thisItemIsAParagraph","adjustedContent","oldStateInline","oldStateList","newlineCoalescer","paragraph","ref","refImage","refLink","fallbackContent","table","row","c","tableSeparator","text","MIN","full","inner","textBolded","MED","textEmphasized","textEscaped","textStrikethroughed","disableParsingRawHTML","htmlBlock","trimmer","trimmed","parseFunc","some","r","tagName","noInnerParse","attrs","htmlSelfClosing","outputFunc","ruleList","Object","keys","nestedParse","ruleType","rule","currCaptureString","substring","parsed","sort","typeA","typeB","orderA","orderB","normalizeWhitespace","parserFor","ast","ruleOutput","nestedReactOutput","Array","isArray","oldKey","lastWasString","nodeOut","isString","def","compiler","MarkdownTextArea","Text","Toggle","Field","name","label","error","wrapperStyle","useContext","standardProps","htmlFor","cancelButton","onSubmit","submitText","Provider","preventDefault"],"mappings":"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"}